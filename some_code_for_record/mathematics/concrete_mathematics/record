为什么要学习递归: 用于解决问题是否是可计算的,可计算才有继续研究的价值
	什么是可计算的:
		一切可计算的函数都可以归结为几种基本的递归的函数的组合
		可计算的函数都可以用递归函数表示
		递归是一种方法论，解决 “能不能” 的命题

Case：存款利率：存钱a0，利率r，第n年有多少钱
		第 n 年：an = an-1 * (1+r);
		第 n-1 年：an-1 = an-2 * (1+r);
		...
		第 1 年：a1 = a0 * (1+r);
		==> an = a0 * (1+r)^n
		a0就是递归基 (base case)
		a0 * (1+r)^n 一般表达式
		从上到下是递归，从下到上是递推

递归的套路：
	递归的表达是不变的，只是参数在缩小，直到递归基
	递归表达式比一般表达式要简单
	注意递归和递推是有区别的

递归就是打开算法的钥匙：
	计算机就是基于冯诺依曼体系的图灵机 | 图灵机和递归函数是等价的 | 故递归就是在计算机的基因里
	二叉树 | 堆 | 搜索二叉树 | 排序 | 动态规划

从递归版本改写为非递归版本
	递归的表达式是线性的，而我们最终需要的是非线性的
	递归是计算机帮你压栈，非递归是自己压栈(stack)

Case : 有 2 、3、5、7 的数，目标是 10 ，有几种方式凑成目标?
		1/ return bool 是否可以。
		2/ return int 有几种方案。
		3/ 这些数可以使用无限次 return int 有几种方案。
		==> 含有n个元素的集合，总共有多少个子集 ==> 2^n个子集

1.1 经典汉诺塔问题 hanoi
	移动最大的盘子n:
		1/ 最大的盘子所在的柱子只能有它一个盘子
		2/ 要移动最大的盘子，还得有一个柱子是空的
		3/ 其他的n-1个盘子都在一个柱子上，且顺序为由小到大
		T(n-1) | 3 |     | 12 | == |   |   | 12 |
			   |   |  3  | 12 | == |   |   | 12 |
			   | 1 |  3  |  2 |
			   | 1 | 23  |    |
			   |   | 123 |    |
		T(n)   |   | 123 |    |
		==> T(n) = T(n-1) + 1 + T(n-1)
				 = 2T(n-1) + 1
		==> T(n) + 1 = 2(T(n-1)+1)
		==> an = 2a(n-1) ==> T(1) + 1 = 2
		==> T(n-1) + 1 = 2^n-1
		==> T(n) = 2^n -1
	进阶问题：4个柱子，每次移动一步，将n个盘子移动到另一个柱子上
				  A		     B		     C		   	  D
			 |1 2 3 4 5|			|			|			|
		A(4) |    5    |			|  1 2 3 4  |			| ==  |	 |  |1 2 3 4|  | 
			 |         |	5		|  1 2 3 4  |			| ==  |	 |  |1 2 3 4|  | 
			 |	1	   |	5		|   2 3 4	|			| A(5) = T(4) + A(1) + A(1)
			 |	1	   |	5		|    3 4	|	2		|
			 |		   |	5		|    3 4	|	1 2		| A(5) = T(3) + A(2) + A(2)
			 |	3	   |	5		|      4	|	1 2		|
			 |	3	   |	4 5		|       	|	1 2		|
			 |		   |  3	4 5		|       	|	1 2		|
			 |	1	   |  3	4 5		|       	|	 2		|
			 |	1	   |  2 3 4 5	|       	|	 		|
		A(5) |		   | 1 2 3 4 5	|       	|	 		|

		==> A(n) = 2A(n-k) + T(k)
		==> A(n) = 2A(n-k) + 2^k - 1

1.2 平面上的直线
	平面上n条直线所界定的区域的最大个数是多少
	数学模型转换：n条直线两两相交，交点彼此不同，这样切分的区域才是最大的
	1/ L(n-1) 再加上一条线
	2/ 按照数学模型的转化：可以将线段分割为n段
	3/ 空间也就多出来了n个
	==> L(n) = L(n-1) + n ==> L(n) = n + n-1 + n-2 ... + 1 + L(0)
	==> L(n) = n(n+1)/2 + L(0) = n(n+1)/2 + 1
